```
           __  ___________    ____  _____    __  ______  __
  __/|_   / / / / ____/   |  / __ \/ ___/   / / / / __ \/ /  __/|_
 |    /  / /_/ / __/ / /| | / / / /\__ \   / / / / /_/ / /  |    /
/_ __|  / __  / /___/ ___ |/ /_/ /___/ /  / /_/ / ____/_/  /_ __|
 |/    /_/ /_/_____/_/  |_/_____//____/   \____/_/   (_)    |/
```

## About

Heads Up! is an bot that plays no-limit poker against you, created for Yale's Automated Descision Systems class in 2015.

No-limit Heads Up Texas Hold 'em is a high stakes, exciting branch of Texas Hold 'em involving only 2 players. Texas Hold 'em is a poker game in which players attempt to create poker hands, and bet in a series of rounds on the outcome of the game. Because bets can be arbitrarily small or large, the size of the game is massive and remains unsolved, unlike Limit Heads Up Texas Hold 'em. You can read more about the game itself here [https://en.wikipedia.org/wiki/Texas_hold_%27em](https://en.wikipedia.org/wiki/Texas_hold_%27em).

The bot also explains its decisions to you after each round based on win percentages generated by Monte Carlo simulations and cost benefit analysis.

The main github repo: [https://github.com/pmaddi/CPSC458_Final-Project](https://github.com/pmaddi/CPSC458_Final-Project)

## Authors

Eric Ho and Pranav Maddi

## Usage
```
python main.py
```

The program explains how to use it in the consle, but whenever you are presented with a prompt, you can bet within a range to call, check or raise. Any number lower than this will be considered a fold.

Note that this should work correctly on the zoo machines without dependencies.

## Game overview

We wrote the Heads Up Texas Hold'em gameply from scratch. This includes having a system for managing cards, players, rounds of play, blinds, and enforcing betting ordering / rules. The cards class is similar to the one used for hw1's blackjack player, and we extend it to hold poker hands. Using these, we wrote methods to evalute and compare the hierarchy of poker hand strengths (high card, pair, two pair, three of a kind, straight, flush, etc.) The classes manage swtiching the blinds for each round, as well as maintainig the player stacks between them. Within each round, cards are dealt to the table hand, and players make matching bets contributing to the pot. While simple in theory, executing this correctly while handling edge cases resulting from betting procedure and the fold / check / call / raise options is tricky.

## Decision Engine

To generate CPU hand strength at any given time, we ran 4 Monte Carlo simulations for at least 1 million simulations each. You can view the results of the simulations in the files preflop\_sim.py, afterflop\_sim.py, afterturn\_sim.py, and afterriver\_sim.py by calling printMatrix(). 

Each simulation has different training features. Our preflop hand strength simulator calculates the number of wins, ties, and losses for every possible starting hand combination of two cards against a random opponent's starting hand combination.

When moving to later rounds, however, things get more difficult. We choose to simulate based on what poker hands that we have already made so far. For example, if after the flop we have a full house, then we train the full house data. However, if we do not have a poker hand yet (if we do not have at least a pair), we need to train on more specific data. Thus, we also divide hands into really strong high card, strong high card, medium high card, weak high card, and really weak high card hands. Additionally, we train on flush draws and straight draws - if a hand has not yet made a pair but has a flush draw or a straight draw, it will train that data instead (and the win percentages of these hands with draws will be higher than ones without). All in all, we have 19 features for afterflop and afterturn, and 16 features for afterriver.

After we calculate hand strength from these Monte Carlo simulations and by categorizing the player's current hand into one of these buckets, we calculate the cost-benefit ratio from the money required to be put in and the money that is already in the pot. We then come up with a strategy after taking into account hand strength, cost benefit ratio, position, bet order, the maximum bet, and the big blind. You can read more about the strategy and view the source code in player.py.

## Next Steps

To improve the CPU, the first step would be to take the table hand into consideration. If the table has strong cards, then the CPU will bet accordingly. The next step after that is to implement some machine learning tactics to understand the opponent. Right now, if the opponent goes all in every single hand, the bot will win most of the time. However, we need some machine learning to punish that poor play even more. We could also simulate the Monte Carlo simulations for more specific features, thus narrowing down true win percentages of hands. Finally, to become very, very smart, the poker CPU will have to understand risk factors such as straight draws or flush draws on the table.
